<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>smile</title>

    <style>
        canvas {
            border: 2px solid black;
        }

    </style>
</head>
<body>
<span id="count-bullet"></span>

<label for="head"></label>
<input type="color" id="head" name="head"/>
<canvas id=canvas width="520" height="520">
</canvas>

<script>
    const SIZE = 40;
    const COUNT_BLOCKS = 6;
    const BULLET_SIZE = 6;

    const HEIGHT_TURRET = 10;
    const WIDTH_TURRET = 25;


    const inp = document.getElementById('head');
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');

    // Element for render
    // [{type: "", ...}]
    let arrayRenderElements = [];

    function render() {

        arrayRenderElements = [
            ...arrayBlock,
            ...arrayBullet,
            tank
        ]


        ctx.clearRect(0, 0, canvas.width, canvas.height)

        arrayRenderElements.forEach(el => {
            switch (el.type) {
                case "block": {
                    ctx.fillStyle = inp.value;
                    ctx.fillRect(el.x, el.y, el.size, el.size);
                    break;
                }
                case "tank": {
                    ctx.fillStyle = 'gray';
                    ctx.fillRect(el.x, el.y, el.size, el.size);

                    switch (el.direction) {
                        case 'right':
                            ctx.fillRect(el.x + el.size, el.y + el.size / 2 - (HEIGHT_TURRET / 2), WIDTH_TURRET, HEIGHT_TURRET);
                            break;
                        case 'left':
                            ctx.fillRect(el.x - WIDTH_TURRET, el.y + el.size / 2 - (HEIGHT_TURRET / 2), WIDTH_TURRET, HEIGHT_TURRET);
                            break;
                        case 'up':
                            ctx.fillRect(el.x + el.size / 2 - HEIGHT_TURRET / 2, el.y - WIDTH_TURRET, HEIGHT_TURRET, WIDTH_TURRET);
                            break;
                        case 'down':
                            ctx.fillRect(el.x + el.size / 2 - HEIGHT_TURRET / 2, el.y + el.size, HEIGHT_TURRET, WIDTH_TURRET);
                            break;
                    }
                    break;
                }
                case 'bullet': {
                    ctx.beginPath();
                    ctx.fillStyle = 'red';
                    ctx.arc(el.x, el.y, el.size / 2, 0, Math.PI * 2);
                    ctx.fill()
                    ctx.closePath();
                    break;
                }
            }
        })
    }

    function tick() {
        const tickTime = (new Date()).getTime();

        arrayBullet.forEach((bullet, index) => {
            // ms
            const diffTime = tickTime - bullet.created;
            switch (bullet.direction) {
                case 'right':
                    bullet.x = bullet.startX + diffTime * bullet.speed + WIDTH_TURRET * 2;
                    break;
                case 'left':
                    bullet.x = bullet.startX - diffTime * bullet.speed - WIDTH_TURRET * 2;
                    break;
                case 'up':
                    bullet.y = bullet.startY - diffTime * bullet.speed - WIDTH_TURRET * 2;
                    break;
                case 'down':
                    bullet.y = bullet.startY + diffTime * bullet.speed + WIDTH_TURRET * 2;
                    break;
            }
            arrayBlock.forEach(block => {
                if (bullet.x <= block.x + 40 && bullet.x >= block.x && bullet.y <= block.y + 40 && bullet.y >= block.y) {

                    arrayBullet.splice(index, 1)
                    arrayBlock.splice(arrayBlock.indexOf(block), 1)
                    let audio = new Audio('zvuk.mp3');
                    audio.play();
                }
            })
        })
        arrayBullet = arrayBullet.filter(bullet => {
            return pointInsideCanvas(bullet.x, bullet.y);
        })

        document.querySelector("#count-bullet").textContent = `Count: ${arrayBullet.length}`
    }

    setInterval(render, 1_000 / 60)
    setInterval(tick, 1_000 / 150)


    /**
     * MODEL DATA
     */
    const tank = generateTank();
    const arrayBlock = generateBlock();
    let arrayBullet = [];
    /*******
     */

    /*
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            arr.forEach(elem => {
                if (elem.image) {
                    ctx.drawImage(elem.image, elem.x, elem.y, size, size);
                } else {
                    ctx.fillRect(elem.x, elem.y, size, size);
                }
            });
            drawSquares();
            drawTank(element.x, element.y);
            drawTurret(element.x + size / 2, element.y + size / 2);
            bullets.forEach((bullet, index) => {
                ctx.beginPath();
                ctx.arc(bullet.x, bullet.y, bulletSize / 2, 0, Math.PI * 2);
                ctx.fillStyle = 'black';
                ctx.fill();
                ctx.closePath();
                bullet.x += Math.cos(bullet.angle) * 4;
                bullet.y += Math.sin(bullet.angle) * 4;

                squares.forEach(square => {
                    if (square.visible && bullet.x > square.x && bullet.x < square.x + square.size &&
                        bullet.y > square.y && bullet.y < square.y + square.size) {
                        square.visible = false;
                        let audio = new Audio('zvuk.mp3');
                        audio.play();
                        bullets.splice(index, 1);
                    }
                });
                if (bullet.x < 0 || bullet.x > canvas.width || bullet.y < 0 || bullet.y > canvas.height) {
                    bullets.splice(index, 1);
                }
            });
            requestAnimationFrame(draw);
        }


        draw();

        function drawTank(x, y) {
            ctx.fillStyle = 'black';
            ctx.fillRect(x, y, size, size);
        }

        function drawTurret(x, y) {
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(turretAngle);
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(size / 2 + size / 2, 0);
            ctx.strokeStyle = '#02061f';
            ctx.lineWidth = 5;
            ctx.stroke();
            ctx.restore();
        }

    */

    canvas.addEventListener('mousedown', function (event) {
        if (event.button === 0) addBullet();
        let audio = new Audio('zvuk-gun.mp3');
        audio.play();
    });
    document.addEventListener('keydown', function (event) {
        switch (event.code) {
            case 'KeyW':
                moveTank(0, -SIZE);
                updateTankDirection('up')

                break;
            case 'KeyS':
                moveTank(0, SIZE);
                updateTankDirection('down')
                break;
            case 'KeyD':
                moveTank(SIZE, 0);
                updateTankDirection('right')
                break;
            case 'KeyA':
                moveTank(-SIZE, 0);
                updateTankDirection('left')
                break;
        }
    });


    function pointInsideCanvas(x, y) {
        return x >= 0 && y >= 0 && x <= canvas.width && y <= canvas.height;
    }

    function updateTankDirection(dir) {
        tank.direction = dir;
    }

    function moveTank(offsetX, offsetY) {
        const newX = tank.x + offsetX;
        const newY = tank.y + offsetY;

        for (let i = 0; i < arrayBlock.length; i++) {
            if (newX < arrayBlock[i].x + SIZE && newX + tank.size > arrayBlock[i].x && newY < arrayBlock[i].y + SIZE && newY + tank.size > arrayBlock[i].y) {
                return;
            }
        }

        if (newX >= 0 && newX <= canvas.width - tank.size && newY >= 0 && newY <= canvas.height - tank.size) {
            tank.x = newX;
            tank.y = newY;
        }
    }

    function addBullet() {


        const startX = tank.x + tank.size / 2;
        const startY = tank.y + tank.size / 2;
        arrayBullet.push({
            startX,
            startY,
            x: startX,
            y: startY,
            size: 10,
            type: 'bullet',
            speed: (SIZE * 2) / 1_000,
            direction: tank.direction,
            created: (new Date()).getTime()
        });
    }

    function generateBlock() {
        return Array.from({length: COUNT_BLOCKS})
        .map(() => {
            const x = Math.floor(Math.random() * (canvas.width / SIZE)) * SIZE;
            const y = Math.floor(Math.random() * (canvas.height / SIZE)) * SIZE;

            return {
                x,
                y,
                size: SIZE,
                type: "block",
                color: "#000"
            }
        })
    }

    function generateTank() {
        return {
            x: 0,
            y: 0,
            size: SIZE,
            type: "tank",
            direction: 'right'
        }
    }
</script>
</body>
</html>