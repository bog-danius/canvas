<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>smile</title>

    <style>
        canvas {
            border: 2px solid black;
        }

    </style>
</head>
<body>
<span id="count-bullet"></span>

<label for="head"></label>
<input type="color" id="head" name="head"/>
<canvas id=canvas width="520" height="520">
</canvas>

<script src = "./assets/js/Vector.js"></script>
<script src = "./assets/js/Box.js"></script>
<script src = "./assets/js/info.js"></script>
<script src = "./assets/js/render.js"></script>
<script>
    const a = new Vector(1,2);
    console.log(a)

    const SIZE = 40;
    const COUNT_BLOCKS = 6;
    const BULLET_SIZE = 6;

    const HEIGHT_TURRET = 10;
    const WIDTH_TURRET = 25;


    const inp = document.getElementById('head');
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');

    // Element for render
    // [{type: "", ...}]
    let arrayRenderElements = [];



    function render() {

        arrayRenderElements = [
            ...arrayBlock,
            ...arrayBullet,
            tank
        ]


        ctx.clearRect(0, 0, canvas.width, canvas.height)

        arrayRenderElements.forEach(el => {

            if (el instanceof Box) {
                ctx.fillStyle = inp.value;
                ctx.fillRect(el.position.x, el.position.y, el.size, el.size);
            }

            switch (el.type) {
                case "tank": {
                    ctx.fillStyle = 'gray';
                    ctx.fillRect(el.x, el.y, el.size, el.size);

                    switch (el.direction) {
                        case 'right':
                            ctx.fillRect(el.x + el.size, el.y + el.size / 2 - (HEIGHT_TURRET / 2), WIDTH_TURRET, HEIGHT_TURRET);
                            break;
                        case 'left':
                            ctx.fillRect(el.x - WIDTH_TURRET, el.y + el.size / 2 - (HEIGHT_TURRET / 2), WIDTH_TURRET, HEIGHT_TURRET);
                            break;
                        case 'up':
                            ctx.fillRect(el.x + el.size / 2 - HEIGHT_TURRET / 2, el.y - WIDTH_TURRET, HEIGHT_TURRET, WIDTH_TURRET);
                            break;
                        case 'down':
                            ctx.fillRect(el.x + el.size / 2 - HEIGHT_TURRET / 2, el.y + el.size, HEIGHT_TURRET, WIDTH_TURRET);
                            break;
                    }
                    break;
                }
                case 'bullet': {
                    ctx.beginPath();
                    ctx.fillStyle = 'red';
                    ctx.arc(el.x, el.y, el.size / 2, 0, Math.PI * 2);
                    ctx.fill()
                    ctx.closePath();
                    break;
                }
            }
        })
    }

    function tick() {
        const tickTime = (new Date()).getTime();

        arrayBullet.forEach((bullet, index) => {
            // ms
            const diffTime = tickTime - bullet.created;
            switch (bullet.direction) {
                case 'right':
                    bullet.x = bullet.startX + diffTime * bullet.speed + WIDTH_TURRET * 2;
                    break;
                case 'left':
                    bullet.x = bullet.startX - diffTime * bullet.speed - WIDTH_TURRET * 2;
                    break;
                case 'up':
                    bullet.y = bullet.startY - diffTime * bullet.speed - WIDTH_TURRET * 2;
                    break;
                case 'down':
                    bullet.y = bullet.startY + diffTime * bullet.speed + WIDTH_TURRET * 2;
                    break;
            }
            arrayBlock.forEach(block => {
                if (bullet.x <= block.position.x + 40 && bullet.x >= block.position.x && bullet.y <= block.position.y + 40 && bullet.y >= block.position.y) {

                    arrayBullet.splice(index, 1)
                    arrayBlock.splice(arrayBlock.indexOf(block), 1)
                    let audio = new Audio('./assets/audio/bang.mp3');
                    audio.play();
                }
            })
        })
        arrayBullet = arrayBullet.filter(bullet => {
            return pointInsideCanvas(bullet.x, bullet.y);
        })

        if (arrayBlock.length === 0) arrayBlock = generateBlock()

        document.querySelector("#count-bullet").textContent = `Count: ${arrayBullet.length}`
    }

    setInterval(render, 1_000 / 60)
    setInterval(tick, 1_000 / 150)

    /**
     * MODEL DATA
     */
    const tank = generateTank();
    let arrayBlock = generateBlock();
    let arrayBullet = [];
    /*******
     */

    canvas.addEventListener('mousedown', function (event) {
        if (event.button === 0) addBullet();
        let audio = new Audio('./assets/audio/zvuk-gun.mp3');
        audio.play();
    });
    document.addEventListener('keydown', function (event) {
        switch (event.code) {
            case 'KeyW':
                moveTank(0, -SIZE);
                updateTankDirection('up')

                break;
            case 'KeyS':
                moveTank(0, SIZE);
                updateTankDirection('down')
                break;
            case 'KeyD':
                moveTank(SIZE, 0);
                updateTankDirection('right')
                break;
            case 'KeyA':
                moveTank(-SIZE, 0);
                updateTankDirection('left')
                break;
        }
    });


    function pointInsideCanvas(x, y) {
        return x >= 0 && y >= 0 && x <= canvas.width && y <= canvas.height;
    }

    function updateTankDirection(dir) {
        tank.direction = dir;
    }

    function moveTank(offsetX, offsetY) {
        const newX = tank.x + offsetX;
        const newY = tank.y + offsetY;

        for (let i = 0; i < arrayBlock.length; i++) {
            if (newX < arrayBlock[i].x + SIZE && newX + tank.size > arrayBlock[i].x && newY < arrayBlock[i].y + SIZE && newY + tank.size > arrayBlock[i].y) {
                return;
            }
        }

        if (newX >= 0 && newX <= canvas.width - tank.size && newY >= 0 && newY <= canvas.height - tank.size) {
            tank.x = newX;
            tank.y = newY;
        }
    }

    function addBullet() {
        const startX = tank.x + tank.size / 2;
        const startY = tank.y + tank.size / 2;
        arrayBullet.push({
            startX,
            startY,
            x: startX,
            y: startY,
            size: 10,
            type: 'bullet',
            speed: (SIZE * 2) / 1_000,
            direction: tank.direction,
            created: (new Date()).getTime()
        });
    }

    function generateBlock() {
        const array =  Array.from({length: COUNT_BLOCKS})
            .map(() => {
                const x = Math.floor(Math.random() * (canvas.width / SIZE)) * SIZE;
                const y = Math.floor(Math.random() * (canvas.height / SIZE)) * SIZE;

                return new Box(
                    new Vector(x, y),
                    SIZE
                )
            })

        return array;
    }

    function generateTank() {
        return {
            x: 0,
            y: 0,
            size: SIZE,
            type: "tank",
            direction: 'right'
        }
    }
</script>
</body>
</html>